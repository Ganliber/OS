# 物理内存管理

> 非连续内存分配

[TOC]



## 非连续分配设计目标

### 连续分配缺点

* 分配给程序的物理内存必须连续
* 存在外碎片和内碎片
* 内存分配的动态修改困难
* 内存利用率低（用户应用进程的需求无法满足）



### 非连续分配的设计目标

> **提高内存利用效率和管理灵活性**

* 允许一个程序使用非连续的物理空间
* 允许共享代码和数据（如函数库）
* 支持动态加载和动态链接

### 需要解决的问题

* VA 与 PA 之间的转换的实现
  * 软件实现：灵活，开销大
  * 硬件实现：够用，开销小
* 非连续分配的硬件辅助机制
  * 如何选择非连续分配中的内存分块大小（规定最小单元，即该单元的物理内存是连续的）
    * 段式存储管理 `segmentation`
      * 单元大小较大，同一段物理地址连续，不同段可以放到不同地方
    * 页式存储管理 `paging`



## 段式存储管理



### 段地址空间

* 进程的段地址空间由多个段组成
  * 主代码段
  * 子模块代码段
  * 公用库代码段
  * 堆栈段`stack`
  * 堆数据`heap`
  * 初始化数据段
  * 符号表
  * 等等... ...
* 段式存储管理的目的
  * 更**细粒度**和**灵活**的分离与共享



### 段地址空间的不连续二维结构

> 依题



### 段访问机制

* 段的概念：
  * 段表示**访问方式**与**存储数据**等属性相同的一段地址空间
  * 对应一个连续内存的"块"
  * 若干个段组成**进程逻辑地址空间**

* 段访问：**逻辑地址由二元组`(s, addr)`表示**

  * s : 段号

  * addr : 段内偏移

  * 段访问的硬件实现

    ```
    Program P
        |
        +
       CPU
        |
        +                                       Memory Exception
    Logical Address : (s, addr)                         +
                       |    |               MMU         | N      Y       Base:addr
                       |    +-------------------> [? <= Limit] -----> [+] -------> PA
                       |                             |                 |
                       | segment                    L+--+b-----+L------+b
                       | descriptor                     |      |
                       +---------> Segment Table : (s, Base, Limit)
                                         +
                                         |
                                  OS set Segment Table
    * PA : Physical Address
    * Limit : 段长度限制
    * The segment table is set by the operating system
    ```

* 逻辑地址与物理地址

  1. `段号`：用来查找段的起始地址，它被存储在段寄存器中
     1. **实方式**下，段号是段值
     2. **保护方式**下，段号是段选择子`Segment selector`
  2. `偏移地址/有效地址`：**存储单元的物理地址与所在段起始地址的差值**
  3. 在`CPU实模式`下，没有分段或分页机制，CPU不进行自动地址转换，**这时程序员操作的就是物理地址**
  4. 无论任何操作，最终都必须要得到物理地址才能在物理内存上进行操作。

  

## 页式存储管理

* 页帧（帧，**物理页面**，Frame, Page Frame)

  * 把物理地址空间划分为大小相同的基本分配单位
  * 大小为`2^n`，如512, 4096 `4K, 32 bit 机器里常见的页帧的大小`, 8192

* 页面（页，**逻辑页面**，Page）

  * 把逻辑地址空间也划分为相同大小的基本分配单位
  * 帧`Frame`和页`Page`的大小必须是相同的

* 页面 --> 页帧 

  > 逻辑地址到物理地址的转换

  * 转换关系：页表
  * 转换关系高效进行：`MMU/TLB`（存储管理单元/快表`Translation Lookaside Buffer`）



### 帧 Frame

* 物理内存被划分成大小相同的帧 `Frame`

  * 内存物理地址表示：二元组 `(f, o)`

    * f : 帧号（F 位，共`2^F`个帧）

    * o : 帧内偏移量（S位，每帧有 `2^S`字节）

    * 物理地址 
      $$
      PA = f * 2^S + o
      $$

    * 实例

      ```
      Assume :
      	1. Address Space : 16-bit
      	2. Frame size : 9-bit (512 bytes) 
      PA Calculation :
      	if PA = (3, 6):
      	   PA = [0000011 000000110](b) --> 16 bit
      	         |     | |       |
         	       15    9 8       0
      	         +=====+ +=======+
      	            3        6
      	    F = 7 bits      S = 9 bits
         	 PA = f * 2^S + o
           1) f = 3
           2) 2^S = 512
           3) o = 6
           4) PA = 3*512 + 6 = 1542
         then :
            The true PA is 1542.    
      ```



### 页 Page

* 进程**逻辑地址空间**被划分为**大小相等的页** `Page`

  * 页内偏移 == 帧内偏移

  * 但通常：页号 != 帧号（逻辑地址空间页号相邻但对应帧号就未必相邻）

  * 进程逻辑地址的表示：二元组`(p, o)`

    * p : 页号（P位，`2^P`个页）

    * o : 页内偏移（S位，每页有`2^S`字节）

    * 虚拟地址
      $$
      VA = p*2^S + o
      $$
      

页式存储中的地址映射

> 1. Page --> Frame 的映射
> 2. Logical Address 页号：连续
> 3. Physical Address 帧号：不连续
> 4. **不是所有的页都有对应的帧**
>
> ---> 页表

* 映射过程

  > 1. 页表保存了逻辑地址（逻辑页号）—物理地址（物理页号）之间的映射关系

  ```
  Program P
     | CPU
     +
   (p, o) <--- Logical Address
    |  |                                o
    |  +-----------------------------------> (f, o) ---> PA
    |                                           +
    |                                   f       |
    +------------> Page Table (p -> f) ---------+
                           +
                           |
                  由页表基址指定开始位置
  ```

  



### 页表

* 结构
  * 每个进程都有一个页表
    * 每个页面对应一个页表项
    * 随进程运行状态而动态变化
    * 页表基址寄存器`PTBR : Page Table Base Register`
  * 页表项组成（部分）
    * 帧号
    * 页表项**标志位**
      * 存在位`resident bit`（有的页可能并没有对应帧号，因为没有分配相应存储，存在位即标志是否有分配）
      * 修改位`dirty bit`
      * 引用位`clock/reference bit `



### 页式存储机制的性能问题

*  内存访问性能问题
  * 访问一个内存单元需要两次内存访问
    * 第一次：获取页表项
    * 第二次：访问数据
* 页表大小问题
  * 页表可能非常大
  * 64-bit 机器如果每页1024 bytes（1K即 2^10 bytes)，那么一个页表的大小会是多少？
    * 2^64 / 2^10 = 2^54 个页表项，每个页表项出去64-bit（8 bytes),还会有标志位等，那么页表的大小将是非常巨大的。
* 处理方案
  * 缓存 `Caching` : 如缓存当前页表项，防止重复查找访问，即——块表
  * 间接访问 `Indirection` : 将大页表切断分级，即——多级页表



### 快表

> Translation Look-aside Buffer, `TLB`

* 缓存近期访问的页表项 `Key:p   --->   Value:f`
  * TLB 使用关联存储`associative memory`实现，具备快速访问性能
  * 如果 TLB 命中，物理页号可以很快被获取
  * 如果 TLB 未命中，对应页表项会被更新到 TLB 中



### 多级页表

* 通过间接引用将页号分成`K`级

  > 访问次数是`K+1`次，前K次页表访问，再加上最后一次物理内存访问

  * 建立页表"树"
  * 有效减少**每一级页表**的长度
  * 有效减少**页表的大小**
    * 由于实际运行的进程，大多数并不会用到所有的逻辑地址空间，因此可以通过各级页表中的存在位将实际不存在的页省去

* 实例：二级页表

  ```
  [p1, p2, o] --> Logical Address
   |    |  +-----------------------------------------------------------------------------+
   |    +----------------------------------------------+                                 |
   |                                                   |                                 |
   +---[+]--->第一级页表( PTBR:p1 )--->第二级页表基址---[+]--->第二级页表( Base-2:p2 )     |
        +                                                       |              +---------+
        | PTBR                                                  |              |
   CR3 -> PTBR (第一级页表基址(存放在寄存器CR3中))                +--> f ---> [f:o] (PA)
  ```

  

### 反置页表

> 为了减少页表所占用存储空间

* 对于大地址空间`64-bit`系统，多级页表变得繁琐

  * 如：5级页表
  * 逻辑（虚拟）地址空间增长速度快于物理地址空间

* **页寄存器**和**反置页表**的思路

  > 由于多级页表中页表项是和逻辑地址空间大小对应的，因此会导致：逻辑（虚拟）地址空间增长速度快于物理地址空间

  * **不让页表与逻辑地址空间大小相对应**
  * 让页表与**物理地址空间**的大小相对应

#### 页寄存器

> `Page Register`

* 每个帧与一个页寄存器`Page Register`相关联，寄存器内容包括
  * 使用位`Residence Bit` : 此帧是否被**进程**占用
  * 占用位号`Occupier` : 对应的页号p（这个p是逻辑地址`(p, o)`的页号p）
  * 保护位`Protection bits` : 约定这一页的访问方式
* 页寄存器实例
  * 物理内存大小：16 MB = 4096*4096 = 4K * 4KB
  * 页面大小：4 KB
  * 页帧数：4096 = 4K
  * 页寄存器使用的空间（假设每个页寄存器占`8 bytes`）
    * 8 bytes * 4K = 32 KB
  * 页寄存器带来的额外开销
    * 32K/16M = 0.2%（大约）---> 还是比较小的
  * 虚拟内存大小：任意（由于页寄存器是和物理地址绑定的，因此逻辑（虚拟）内存大小就任意了）

##### 页寄存器方案的优缺点

* 优点
  * 页表大小想对于物理内存而言很小
  * 页表大小与逻辑地址空间大小无关
* 缺点
  * 页表信息对调后，需要依据**帧号**找**页号**
  * 在**页寄存器**中搜索逻辑地址中的页号

##### 页寄存器中的地址转换

* CPU生成的逻辑地址如何找到对应的物理地址
  * 对逻辑地址进行`Hash`映射，以**减少搜索范围**
  * 需要解决可能的冲突
* 利用快表缓存页表项后的页寄存器搜索步骤
  * 对`LA`进行`Hash`变换
  * 在`TLB`中查找对应页表项
  * 有冲突时遍历冲突项链表
  * 查找失败时，产生异常

* 快表`TLB`限制
  * 快表容量限制
  * 快表功耗限制





#### 反置页表

> **与页寄存器的做法区别在于反置页表将进程ID也考虑了进来**
>
> 反置页表

* 基于`Hash`映射值查找对应页表项中的**帧号**

  * 进程标识与页号的`Hash`值可能有冲突
  * 页表项中包括`flag bit`：保护位，修改位，访问位，存在位等标识

  ```
   CPU
    |
    +
  (p, o)            PID
    |                |
    +--------+-------+-----------------------+
             |                               |
            Hash <-- conflict resolution     |
             |                               |
   PTBR --> [+] --> (PID, p, flag bit)  <----+ check PID and p
                            | check successfully
                            +-------> f --------------> (f, o) [ Memory ]
   
   * Hash 的结果是页帧号，反置列表以页帧号Frame index作为key排序的
   * 需要到相应的页表项中核对PID和p
  ```

  1. Hash是根据`LA`和`PID`---> index table（索引表）

  2. 根据index ---> **反置列表**中进行查找 ---> 检查 PID 和 LA

  3. 一样：取出`f` ---> `(f, o)` --->memory

  4. 不一样会产生冲突：这时候会根据反置页表中的`next`项找到下一个进行比对，如果

     ```
     Assume : (pid, p, offset) == (8, 0x1, 0x1234) ----------------------------------+
                                                                                     |
     (8, 0x1) ----Hash---> index : 0x176F9 --+                                       |
                                             |                                       |
       +-------------------------------------+                                       |
       |                                                                             |
       |        +----------+----------+----------+----------+                        |
       |        | index    | pid      | p        | next     |                        |
       |        +----------+----------+----------+----------+   * conflict!          |
       +----->  | 0x176F9  | 1        | 0xA63    | 0x18F18  |  -----+                |
                +----------+----------+----------+----------+       |                |
                |          | ...      | ...      | ...      |       |                |
                +----------+----------+----------+----------+       |                |
                |          | 8        | 0x1      | 0x0A921  |  <----+                |
                +----------+----------+----------+----------+   * conflict solved!   |
                                                      |                              |
                                                      |                              |
                                                      +---> f:0x0A921  o:0x1234  <---+
                                                            (f, o) --> 
     * index 是基于 frame index 的
     ```

     











