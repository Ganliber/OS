# 物理内存管理

> 非连续内存分配

[TOC]



## 非连续分配设计目标

### 连续分配缺点

* 分配给程序的物理内存必须连续
* 存在外碎片和内碎片
* 内存分配的动态修改困难
* 内存利用率低（用户应用进程的需求无法满足）



### 非连续分配的设计目标

> **提高内存利用效率和管理灵活性**

* 允许一个程序使用非连续的物理空间
* 允许共享代码和数据（如函数库）
* 支持动态加载和动态链接

### 需要解决的问题

* VA 与 PA 之间的转换的实现
  * 软件实现：灵活，开销大
  * 硬件实现：够用，开销小
* 非连续分配的硬件辅助机制
  * 如何选择非连续分配中的内存分块大小（规定最小单元，即该单元的物理内存是连续的）
    * 段式存储管理 `segmentation`
      * 单元大小较大，同一段物理地址连续，不同段可以放到不同地方
    * 页式存储管理 `paging`



## 段式存储管理



### 段地址空间

* 进程的段地址空间由多个段组成
  * 主代码段
  * 子模块代码段
  * 公用库代码段
  * 堆栈段`stack`
  * 堆数据`heap`
  * 初始化数据段
  * 符号表
  * 等等... ...
* 段式存储管理的目的
  * 更**细粒度**和**灵活**的分离与共享



### 段地址空间的不连续二维结构

> 依题



### 段访问机制

* 段的概念：
  * 段表示**访问方式**与**存储数据**等属性相同的一段地址空间
  * 对应一个连续内存的"块"
  * 若干个段组成**进程逻辑地址空间**

* 段访问：**逻辑地址由二元组`(s, addr)`表示**

  * s : 段号

  * addr : 段内偏移

  * 段访问的硬件实现

    ```
    Program P
        |
        +
       CPU
        |
        +                                       Memory Exception
    Logical Address : (s, addr)                         +
                       |    |               MMU         | N      Y       Base:addr
                       |    +-------------------> [? <= Limit] -----> [+] -------> PA
                       |                             |                 |
                       | segment                    L+--+b-----+L------+b
                       | descriptor                     |      |
                       +---------> Segment Table : (s, Base, Limit)
                                         +
                                         |
                                  OS set Segment Table
    * PA : Physical Address
    * Limit : 段长度限制
    * The segment table is set by the operating system
    ```

* 逻辑地址与物理地址

  1. `段号`：用来查找段的起始地址，它被存储在段寄存器中
     1. **实方式**下，段号是段值
     2. **保护方式**下，段号是段选择子`Segment selector`
  2. `偏移地址/有效地址`：**存储单元的物理地址与所在段起始地址的差值**
  3. 在`CPU实模式`下，没有分段或分页机制，CPU不进行自动地址转换，**这时程序员操作的就是物理地址**
  4. 无论任何操作，最终都必须要得到物理地址才能在物理内存上进行操作。

  

## 页式存储管理

* 页帧（帧，**物理页面**，Frame, Page Frame)

  * 把物理地址空间划分为大小相同的基本分配单位
  * 大小为`2^n`，如512, 4096 `4K, 32 bit 机器里常见的页帧的大小`, 8192

* 页面（页，**逻辑页面**，Page）

  * 把逻辑地址空间也划分为相同大小的基本分配单位
  * 帧`Frame`和页`Page`的大小必须是相同的

* 页面 --> 页帧 

  > 逻辑地址到物理地址的转换

  * 转换关系：页表
  * 转换关系高效进行：`MMU/TLB`（存储管理单元/快表`Translation Lookaside Buffer`）



### 帧 Frame

* 物理内存被划分成大小相同的帧 `Frame`

  * 内存物理地址表示：二元组 `(f, o)`

    * f : 帧号（F 位，共`2^F`个帧）

    * o : 帧内偏移量（S位，每帧有 `2^S`字节）

    * 物理地址 
      $$
      PA = f * 2^S + o
      $$

    * 实例

      ```
      Assume :
      	1. Address Space : 16-bit
      	2. Frame size : 9-bit (512 bytes) 
      PA Calculation :
      	if PA = (3, 6):
      	   PA = [0000011 000000110](b) --> 16 bit
      	         |     | |       |
         	       15    9 8       0
      	         +=====+ +=======+
      	            3        6
      	    F = 7 bits      S = 9 bits
         	 PA = f * 2^S + o
           1) f = 3
           2) 2^S = 512
           3) o = 6
           4) PA = 3*512 + 6 = 1542
         then :
            The true PA is 1542.    
      ```



### 页 Page

* 进程**逻辑地址空间**被划分为**大小相等的页** `Page`

  * 页内偏移 == 帧内偏移

  * 但通常：页号 != 帧号（逻辑地址空间页号相邻但对应帧号就未必相邻）

  * 进程逻辑地址的表示：二元组`(p, o)`

    * p : 页号（P位，`2^P`个页）

    * o : 页内偏移（S位，每页有`2^S`字节）

    * 虚拟地址
      $$
      VA = p*2^S + o
      $$
      

页式存储中的地址映射

> 1. Page --> Frame 的映射
> 2. Logical Address 页号：连续
> 3. Physical Address 帧号：不连续
> 4. **不是所有的页都有对应的帧**
>
> ---> 页表

* 映射过程

  > 1. 页表保存了逻辑地址（逻辑页号）—物理地址（物理页号）之间的映射关系

  ```
  Program P
     | CPU
     +
   (p, o) <--- Logical Address
    |  |                                o
    |  +-----------------------------------> (f, o) ---> PA
    |                                           +
    |                                   f       |
    +------------> Page Table (p -> f) ---------+
                           +
                           |
                  由页表基址指定开始位置
  ```

  



### 页表

* 结构
  * 每个进程都有一个页表
    * 每个页面对应一个页表项
    * 随进程运行状态而动态变化
    * 页表基址寄存器`PTBR : Page Table Base Register`
  * 页表项组成（部分）
    * 帧号
    * 页表项**标志位**
      * 存在位`resident bit`（有的页可能并没有对应帧号，因为没有分配相应存储，存在位即标志是否有分配）
      * 修改位`dirty bit`
      * 引用位`clock/reference bit `



### 页式存储机制的性能问题

*  内存访问性能问题
  * 访问一个内存单元需要两次内存访问
    * 第一次：获取页表项
    * 第二次：访问数据
* 页表大小问题
  * 页表可能非常大
  * 64-bit 机器如果每页1024 bytes（1K即 2^10 bytes)，那么一个页表的大小会是多少？
    * 2^64 / 2^10 = 2^54 个页表项，每个页表项出去64-bit（8 bytes),还会有标志位等，那么页表的大小将是非常巨大的。
* 处理方案
  * 缓存 `Caching` : 如缓存当前页表项，防止重复查找访问
  * 间接访问 `Indirection` : 将大页表切断分级，即——多级页表



### 块表



### 多级页表







